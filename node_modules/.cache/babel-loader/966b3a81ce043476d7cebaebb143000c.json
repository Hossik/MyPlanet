{"ast":null,"code":"\"use strict\";\n\nvar getPropertyDescriptor = require(\"./get-property-descriptor\");\n\nvar valueToString = require(\"./value-to-string\");\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction isFunction(obj) {\n  return typeof obj === \"function\" || !!(obj && obj.constructor && obj.call && obj.apply);\n}\n\nfunction mirrorProperties(target, source) {\n  for (var prop in source) {\n    if (!hasOwn.call(target, prop)) {\n      target[prop] = source[prop];\n    }\n  }\n} // Cheap way to detect if we have ES5 support.\n\n\nvar hasES5Support = (\"keys\" in Object);\n\nmodule.exports = function wrapMethod(object, property, method) {\n  if (!object) {\n    throw new TypeError(\"Should wrap property of object\");\n  }\n\n  if (typeof method !== \"function\" && typeof method !== \"object\") {\n    throw new TypeError(\"Method wrapper should be a function or a property descriptor\");\n  }\n\n  function checkWrappedMethod(wrappedMethod) {\n    var error;\n\n    if (!isFunction(wrappedMethod)) {\n      error = new TypeError(\"Attempted to wrap \" + typeof wrappedMethod + \" property \" + valueToString(property) + \" as function\");\n    } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n      error = new TypeError(\"Attempted to wrap \" + valueToString(property) + \" which is already wrapped\");\n    } else if (wrappedMethod.calledBefore) {\n      var verb = wrappedMethod.returns ? \"stubbed\" : \"spied on\";\n      error = new TypeError(\"Attempted to wrap \" + valueToString(property) + \" which is already \" + verb);\n    }\n\n    if (error) {\n      if (wrappedMethod && wrappedMethod.stackTrace) {\n        error.stack += \"\\n--------------\\n\" + wrappedMethod.stackTrace;\n      }\n\n      throw error;\n    }\n  }\n\n  var error, wrappedMethod, i;\n\n  function simplePropertyAssignment() {\n    wrappedMethod = object[property];\n    checkWrappedMethod(wrappedMethod);\n    object[property] = method;\n    method.displayName = property;\n  } // Firefox has a problem when using hasOwn.call on objects from other frames.\n\n\n  var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);\n\n  if (hasES5Support) {\n    var methodDesc = typeof method === \"function\" ? {\n      value: method\n    } : method;\n    var wrappedMethodDesc = getPropertyDescriptor(object, property);\n\n    if (!wrappedMethodDesc) {\n      error = new TypeError(\"Attempted to wrap \" + typeof wrappedMethod + \" property \" + property + \" as function\");\n    } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {\n      error = new TypeError(\"Attempted to wrap \" + property + \" which is already wrapped\");\n    }\n\n    if (error) {\n      if (wrappedMethodDesc && wrappedMethodDesc.stackTrace) {\n        error.stack += \"\\n--------------\\n\" + wrappedMethodDesc.stackTrace;\n      }\n\n      throw error;\n    }\n\n    var types = Object.keys(methodDesc);\n\n    for (i = 0; i < types.length; i++) {\n      wrappedMethod = wrappedMethodDesc[types[i]];\n      checkWrappedMethod(wrappedMethod);\n    }\n\n    mirrorProperties(methodDesc, wrappedMethodDesc);\n\n    for (i = 0; i < types.length; i++) {\n      mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);\n    }\n\n    Object.defineProperty(object, property, methodDesc); // catch failing assignment\n    // this is the converse of the check in `.restore` below\n\n    if (typeof method === \"function\" && object[property] !== method) {\n      // correct any wrongdoings caused by the defineProperty call above,\n      // such as adding new items (if object was a Storage object)\n      delete object[property];\n      simplePropertyAssignment();\n    }\n  } else {\n    simplePropertyAssignment();\n  }\n\n  method.displayName = property; // Set up a stack trace which can be used later to find what line of\n  // code the original method was created on.\n\n  method.stackTrace = new Error(\"Stack Trace for original\").stack;\n\n  method.restore = function () {\n    // For prototype properties try to reset by delete first.\n    // If this fails (ex: localStorage on mobile safari) then force a reset\n    // via direct assignment.\n    if (!owned) {\n      // In some cases `delete` may throw an error\n      try {\n        delete object[property];\n      } catch (e) {} // eslint-disable-line no-empty\n      // For native code functions `delete` fails without throwing an error\n      // on Chrome < 43, PhantomJS, etc.\n\n    } else if (hasES5Support) {\n      Object.defineProperty(object, property, wrappedMethodDesc);\n    }\n\n    if (hasES5Support) {\n      var descriptor = getPropertyDescriptor(object, property);\n\n      if (descriptor && descriptor.value === method) {\n        object[property] = wrappedMethod;\n      }\n    } else {\n      // Use strict equality comparison to check failures then force a reset\n      // via direct assignment.\n      if (object[property] === method) {\n        object[property] = wrappedMethod;\n      }\n    }\n  };\n\n  method.wrappedMethod = wrappedMethod;\n  method.restore.sinon = true;\n\n  if (!hasES5Support) {\n    mirrorProperties(method, wrappedMethod);\n  }\n\n  return method;\n};","map":{"version":3,"sources":["/home/hoss/my App/my-app/node_modules/sinon/lib/sinon/util/core/wrap-method.js"],"names":["getPropertyDescriptor","require","valueToString","hasOwn","Object","prototype","hasOwnProperty","isFunction","obj","constructor","call","apply","mirrorProperties","target","source","prop","hasES5Support","module","exports","wrapMethod","object","property","method","TypeError","checkWrappedMethod","wrappedMethod","error","restore","sinon","calledBefore","verb","returns","stackTrace","stack","i","simplePropertyAssignment","displayName","owned","methodDesc","value","wrappedMethodDesc","types","keys","length","defineProperty","Error","e","descriptor"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar getPropertyDescriptor = require(\"./get-property-descriptor\");\nvar valueToString = require(\"./value-to-string\");\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction isFunction(obj) {\n    return typeof obj === \"function\" || !!(obj && obj.constructor && obj.call && obj.apply);\n}\n\nfunction mirrorProperties(target, source) {\n    for (var prop in source) {\n        if (!hasOwn.call(target, prop)) {\n            target[prop] = source[prop];\n        }\n    }\n}\n\n// Cheap way to detect if we have ES5 support.\nvar hasES5Support = \"keys\" in Object;\n\nmodule.exports = function wrapMethod(object, property, method) {\n    if (!object) {\n        throw new TypeError(\"Should wrap property of object\");\n    }\n\n    if (typeof method !== \"function\" && typeof method !== \"object\") {\n        throw new TypeError(\"Method wrapper should be a function or a property descriptor\");\n    }\n\n    function checkWrappedMethod(wrappedMethod) {\n        var error;\n\n        if (!isFunction(wrappedMethod)) {\n            error = new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\n                                valueToString(property) + \" as function\");\n        } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n            error = new TypeError(\"Attempted to wrap \" + valueToString(property) + \" which is already wrapped\");\n        } else if (wrappedMethod.calledBefore) {\n            var verb = wrappedMethod.returns ? \"stubbed\" : \"spied on\";\n            error = new TypeError(\"Attempted to wrap \" + valueToString(property) + \" which is already \" + verb);\n        }\n\n        if (error) {\n            if (wrappedMethod && wrappedMethod.stackTrace) {\n                error.stack += \"\\n--------------\\n\" + wrappedMethod.stackTrace;\n            }\n            throw error;\n        }\n    }\n\n    var error, wrappedMethod, i;\n\n    function simplePropertyAssignment() {\n        wrappedMethod = object[property];\n        checkWrappedMethod(wrappedMethod);\n        object[property] = method;\n        method.displayName = property;\n    }\n\n    // Firefox has a problem when using hasOwn.call on objects from other frames.\n    var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);\n\n    if (hasES5Support) {\n        var methodDesc = (typeof method === \"function\") ? {value: method} : method;\n        var wrappedMethodDesc = getPropertyDescriptor(object, property);\n\n        if (!wrappedMethodDesc) {\n            error = new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\n                                property + \" as function\");\n        } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {\n            error = new TypeError(\"Attempted to wrap \" + property + \" which is already wrapped\");\n        }\n        if (error) {\n            if (wrappedMethodDesc && wrappedMethodDesc.stackTrace) {\n                error.stack += \"\\n--------------\\n\" + wrappedMethodDesc.stackTrace;\n            }\n            throw error;\n        }\n\n        var types = Object.keys(methodDesc);\n        for (i = 0; i < types.length; i++) {\n            wrappedMethod = wrappedMethodDesc[types[i]];\n            checkWrappedMethod(wrappedMethod);\n        }\n\n        mirrorProperties(methodDesc, wrappedMethodDesc);\n        for (i = 0; i < types.length; i++) {\n            mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);\n        }\n        Object.defineProperty(object, property, methodDesc);\n\n        // catch failing assignment\n        // this is the converse of the check in `.restore` below\n        if ( typeof method === \"function\" && object[property] !== method ) {\n            // correct any wrongdoings caused by the defineProperty call above,\n            // such as adding new items (if object was a Storage object)\n            delete object[property];\n            simplePropertyAssignment();\n        }\n    } else {\n        simplePropertyAssignment();\n    }\n\n    method.displayName = property;\n\n    // Set up a stack trace which can be used later to find what line of\n    // code the original method was created on.\n    method.stackTrace = (new Error(\"Stack Trace for original\")).stack;\n\n    method.restore = function () {\n        // For prototype properties try to reset by delete first.\n        // If this fails (ex: localStorage on mobile safari) then force a reset\n        // via direct assignment.\n        if (!owned) {\n            // In some cases `delete` may throw an error\n            try {\n                delete object[property];\n            } catch (e) {} // eslint-disable-line no-empty\n            // For native code functions `delete` fails without throwing an error\n            // on Chrome < 43, PhantomJS, etc.\n        } else if (hasES5Support) {\n            Object.defineProperty(object, property, wrappedMethodDesc);\n        }\n\n        if (hasES5Support) {\n            var descriptor = getPropertyDescriptor(object, property);\n            if (descriptor && descriptor.value === method) {\n                object[property] = wrappedMethod;\n            }\n        }\n        else {\n        // Use strict equality comparison to check failures then force a reset\n        // via direct assignment.\n            if (object[property] === method) {\n                object[property] = wrappedMethod;\n            }\n        }\n    };\n\n    method.wrappedMethod = wrappedMethod;\n\n    method.restore.sinon = true;\n\n    if (!hasES5Support) {\n        mirrorProperties(method, wrappedMethod);\n    }\n\n    return method;\n};\n"]},"metadata":{},"sourceType":"script"}