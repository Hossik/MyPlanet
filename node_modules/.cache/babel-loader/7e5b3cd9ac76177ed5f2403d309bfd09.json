{"ast":null,"code":"\"use strict\";\n\nvar spyInvoke = require(\"./spy\").invoke;\n\nvar spyCallToString = require(\"./call\").toString;\n\nvar timesInWords = require(\"./util/core/times-in-words\");\n\nvar extend = require(\"./util/core/extend\");\n\nvar match = require(\"./match\");\n\nvar stub = require(\"./stub\");\n\nvar assert = require(\"./assert\");\n\nvar deepEqual = require(\"./util/core/deep-equal\").use(match);\n\nvar format = require(\"./util/core/format\");\n\nvar valueToString = require(\"./util/core/value-to-string\");\n\nvar slice = Array.prototype.slice;\nvar push = Array.prototype.push;\n\nfunction callCountInWords(callCount) {\n  if (callCount === 0) {\n    return \"never called\";\n  }\n\n  return \"called \" + timesInWords(callCount);\n}\n\nfunction expectedCallCountInWords(expectation) {\n  var min = expectation.minCalls;\n  var max = expectation.maxCalls;\n\n  if (typeof min === \"number\" && typeof max === \"number\") {\n    var str = timesInWords(min);\n\n    if (min !== max) {\n      str = \"at least \" + str + \" and at most \" + timesInWords(max);\n    }\n\n    return str;\n  }\n\n  if (typeof min === \"number\") {\n    return \"at least \" + timesInWords(min);\n  }\n\n  return \"at most \" + timesInWords(max);\n}\n\nfunction receivedMinCalls(expectation) {\n  var hasMinLimit = typeof expectation.minCalls === \"number\";\n  return !hasMinLimit || expectation.callCount >= expectation.minCalls;\n}\n\nfunction receivedMaxCalls(expectation) {\n  if (typeof expectation.maxCalls !== \"number\") {\n    return false;\n  }\n\n  return expectation.callCount === expectation.maxCalls;\n}\n\nfunction verifyMatcher(possibleMatcher, arg) {\n  var isMatcher = match && match.isMatcher(possibleMatcher);\n  return isMatcher && possibleMatcher.test(arg) || true;\n}\n\nvar mockExpectation = {\n  minCalls: 1,\n  maxCalls: 1,\n  create: function create(methodName) {\n    var expectation = extend(stub.create(), mockExpectation);\n    delete expectation.create;\n    expectation.method = methodName;\n    return expectation;\n  },\n  invoke: function invoke(func, thisValue, args) {\n    this.verifyCallAllowed(thisValue, args);\n    return spyInvoke.apply(this, arguments);\n  },\n  atLeast: function atLeast(num) {\n    if (typeof num !== \"number\") {\n      throw new TypeError(\"'\" + valueToString(num) + \"' is not number\");\n    }\n\n    if (!this.limitsSet) {\n      this.maxCalls = null;\n      this.limitsSet = true;\n    }\n\n    this.minCalls = num;\n    return this;\n  },\n  atMost: function atMost(num) {\n    if (typeof num !== \"number\") {\n      throw new TypeError(\"'\" + valueToString(num) + \"' is not number\");\n    }\n\n    if (!this.limitsSet) {\n      this.minCalls = null;\n      this.limitsSet = true;\n    }\n\n    this.maxCalls = num;\n    return this;\n  },\n  never: function never() {\n    return this.exactly(0);\n  },\n  once: function once() {\n    return this.exactly(1);\n  },\n  twice: function twice() {\n    return this.exactly(2);\n  },\n  thrice: function thrice() {\n    return this.exactly(3);\n  },\n  exactly: function exactly(num) {\n    if (typeof num !== \"number\") {\n      throw new TypeError(\"'\" + valueToString(num) + \"' is not a number\");\n    }\n\n    this.atLeast(num);\n    return this.atMost(num);\n  },\n  met: function met() {\n    return !this.failed && receivedMinCalls(this);\n  },\n  verifyCallAllowed: function verifyCallAllowed(thisValue, args) {\n    var expectedArguments = this.expectedArguments;\n\n    if (receivedMaxCalls(this)) {\n      this.failed = true;\n      mockExpectation.fail(this.method + \" already called \" + timesInWords(this.maxCalls));\n    }\n\n    if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n      mockExpectation.fail(this.method + \" called with \" + valueToString(thisValue) + \" as thisValue, expected \" + valueToString(this.expectedThis));\n    }\n\n    if (!(\"expectedArguments\" in this)) {\n      return;\n    }\n\n    if (!args) {\n      mockExpectation.fail(this.method + \" received no arguments, expected \" + format(expectedArguments));\n    }\n\n    if (args.length < expectedArguments.length) {\n      mockExpectation.fail(this.method + \" received too few arguments (\" + format(args) + \"), expected \" + format(expectedArguments));\n    }\n\n    if (this.expectsExactArgCount && args.length !== expectedArguments.length) {\n      mockExpectation.fail(this.method + \" received too many arguments (\" + format(args) + \"), expected \" + format(expectedArguments));\n    }\n\n    expectedArguments.forEach(function (expectedArgument, i) {\n      if (!verifyMatcher(expectedArgument, args[i])) {\n        mockExpectation.fail(this.method + \" received wrong arguments \" + format(args) + \", didn't match \" + expectedArguments.toString());\n      }\n\n      if (!deepEqual(expectedArgument, args[i])) {\n        mockExpectation.fail(this.method + \" received wrong arguments \" + format(args) + \", expected \" + format(expectedArguments));\n      }\n    }, this);\n  },\n  allowsCall: function allowsCall(thisValue, args) {\n    var expectedArguments = this.expectedArguments;\n\n    if (this.met() && receivedMaxCalls(this)) {\n      return false;\n    }\n\n    if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n      return false;\n    }\n\n    if (!(\"expectedArguments\" in this)) {\n      return true;\n    }\n\n    args = args || [];\n\n    if (args.length < expectedArguments.length) {\n      return false;\n    }\n\n    if (this.expectsExactArgCount && args.length !== expectedArguments.length) {\n      return false;\n    }\n\n    return expectedArguments.every(function (expectedArgument, i) {\n      if (!verifyMatcher(expectedArgument, args[i])) {\n        return false;\n      }\n\n      if (!deepEqual(expectedArgument, args[i])) {\n        return false;\n      }\n\n      return true;\n    });\n  },\n  withArgs: function withArgs() {\n    this.expectedArguments = slice.call(arguments);\n    return this;\n  },\n  withExactArgs: function withExactArgs() {\n    this.withArgs.apply(this, arguments);\n    this.expectsExactArgCount = true;\n    return this;\n  },\n  on: function on(thisValue) {\n    this.expectedThis = thisValue;\n    return this;\n  },\n  toString: function () {\n    var args = (this.expectedArguments || []).slice();\n\n    if (!this.expectsExactArgCount) {\n      push.call(args, \"[...]\");\n    }\n\n    var callStr = spyCallToString.call({\n      proxy: this.method || \"anonymous mock expectation\",\n      args: args\n    });\n    var message = callStr.replace(\", [...\", \"[, ...\") + \" \" + expectedCallCountInWords(this);\n\n    if (this.met()) {\n      return \"Expectation met: \" + message;\n    }\n\n    return \"Expected \" + message + \" (\" + callCountInWords(this.callCount) + \")\";\n  },\n  verify: function verify() {\n    if (!this.met()) {\n      mockExpectation.fail(this.toString());\n    } else {\n      mockExpectation.pass(this.toString());\n    }\n\n    return true;\n  },\n  pass: function pass(message) {\n    assert.pass(message);\n  },\n  fail: function fail(message) {\n    var exception = new Error(message);\n    exception.name = \"ExpectationError\";\n    throw exception;\n  }\n};\nmodule.exports = mockExpectation;","map":{"version":3,"sources":["/home/hoss/my App/my-app/node_modules/sinon/lib/sinon/mock-expectation.js"],"names":["spyInvoke","require","invoke","spyCallToString","toString","timesInWords","extend","match","stub","assert","deepEqual","use","format","valueToString","slice","Array","prototype","push","callCountInWords","callCount","expectedCallCountInWords","expectation","min","minCalls","max","maxCalls","str","receivedMinCalls","hasMinLimit","receivedMaxCalls","verifyMatcher","possibleMatcher","arg","isMatcher","test","mockExpectation","create","methodName","method","func","thisValue","args","verifyCallAllowed","apply","arguments","atLeast","num","TypeError","limitsSet","atMost","never","exactly","once","twice","thrice","met","failed","expectedArguments","fail","expectedThis","length","expectsExactArgCount","forEach","expectedArgument","i","allowsCall","every","withArgs","call","withExactArgs","on","callStr","proxy","message","replace","verify","pass","exception","Error","name","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar spyInvoke = require(\"./spy\").invoke;\nvar spyCallToString = require(\"./call\").toString;\nvar timesInWords = require(\"./util/core/times-in-words\");\nvar extend = require(\"./util/core/extend\");\nvar match = require(\"./match\");\nvar stub = require(\"./stub\");\nvar assert = require(\"./assert\");\nvar deepEqual = require(\"./util/core/deep-equal\").use(match);\nvar format = require(\"./util/core/format\");\nvar valueToString = require(\"./util/core/value-to-string\");\n\nvar slice = Array.prototype.slice;\nvar push = Array.prototype.push;\n\nfunction callCountInWords(callCount) {\n    if (callCount === 0) {\n        return \"never called\";\n    }\n\n    return \"called \" + timesInWords(callCount);\n}\n\nfunction expectedCallCountInWords(expectation) {\n    var min = expectation.minCalls;\n    var max = expectation.maxCalls;\n\n    if (typeof min === \"number\" && typeof max === \"number\") {\n        var str = timesInWords(min);\n\n        if (min !== max) {\n            str = \"at least \" + str + \" and at most \" + timesInWords(max);\n        }\n\n        return str;\n    }\n\n    if (typeof min === \"number\") {\n        return \"at least \" + timesInWords(min);\n    }\n\n    return \"at most \" + timesInWords(max);\n}\n\nfunction receivedMinCalls(expectation) {\n    var hasMinLimit = typeof expectation.minCalls === \"number\";\n    return !hasMinLimit || expectation.callCount >= expectation.minCalls;\n}\n\nfunction receivedMaxCalls(expectation) {\n    if (typeof expectation.maxCalls !== \"number\") {\n        return false;\n    }\n\n    return expectation.callCount === expectation.maxCalls;\n}\n\nfunction verifyMatcher(possibleMatcher, arg) {\n    var isMatcher = match && match.isMatcher(possibleMatcher);\n\n    return isMatcher && possibleMatcher.test(arg) || true;\n}\n\nvar mockExpectation = {\n    minCalls: 1,\n    maxCalls: 1,\n\n    create: function create(methodName) {\n        var expectation = extend(stub.create(), mockExpectation);\n        delete expectation.create;\n        expectation.method = methodName;\n\n        return expectation;\n    },\n\n    invoke: function invoke(func, thisValue, args) {\n        this.verifyCallAllowed(thisValue, args);\n\n        return spyInvoke.apply(this, arguments);\n    },\n\n    atLeast: function atLeast(num) {\n        if (typeof num !== \"number\") {\n            throw new TypeError(\"'\" + valueToString(num) + \"' is not number\");\n        }\n\n        if (!this.limitsSet) {\n            this.maxCalls = null;\n            this.limitsSet = true;\n        }\n\n        this.minCalls = num;\n\n        return this;\n    },\n\n    atMost: function atMost(num) {\n        if (typeof num !== \"number\") {\n            throw new TypeError(\"'\" + valueToString(num) + \"' is not number\");\n        }\n\n        if (!this.limitsSet) {\n            this.minCalls = null;\n            this.limitsSet = true;\n        }\n\n        this.maxCalls = num;\n\n        return this;\n    },\n\n    never: function never() {\n        return this.exactly(0);\n    },\n\n    once: function once() {\n        return this.exactly(1);\n    },\n\n    twice: function twice() {\n        return this.exactly(2);\n    },\n\n    thrice: function thrice() {\n        return this.exactly(3);\n    },\n\n    exactly: function exactly(num) {\n        if (typeof num !== \"number\") {\n            throw new TypeError(\"'\" + valueToString(num) + \"' is not a number\");\n        }\n\n        this.atLeast(num);\n        return this.atMost(num);\n    },\n\n    met: function met() {\n        return !this.failed && receivedMinCalls(this);\n    },\n\n    verifyCallAllowed: function verifyCallAllowed(thisValue, args) {\n        var expectedArguments = this.expectedArguments;\n\n        if (receivedMaxCalls(this)) {\n            this.failed = true;\n            mockExpectation.fail(this.method + \" already called \" + timesInWords(this.maxCalls));\n        }\n\n        if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n            mockExpectation.fail(this.method + \" called with \" + valueToString(thisValue) +\n                \" as thisValue, expected \" + valueToString(this.expectedThis));\n        }\n\n        if (!(\"expectedArguments\" in this)) {\n            return;\n        }\n\n        if (!args) {\n            mockExpectation.fail(this.method + \" received no arguments, expected \" +\n                format(expectedArguments));\n        }\n\n        if (args.length < expectedArguments.length) {\n            mockExpectation.fail(this.method + \" received too few arguments (\" + format(args) +\n                \"), expected \" + format(expectedArguments));\n        }\n\n        if (this.expectsExactArgCount &&\n            args.length !== expectedArguments.length) {\n            mockExpectation.fail(this.method + \" received too many arguments (\" + format(args) +\n                \"), expected \" + format(expectedArguments));\n        }\n\n        expectedArguments.forEach(function (expectedArgument, i) {\n            if (!verifyMatcher(expectedArgument, args[i])) {\n                mockExpectation.fail(this.method + \" received wrong arguments \" + format(args) +\n                    \", didn't match \" + expectedArguments.toString());\n            }\n\n            if (!deepEqual(expectedArgument, args[i])) {\n                mockExpectation.fail(this.method + \" received wrong arguments \" + format(args) +\n                    \", expected \" + format(expectedArguments));\n            }\n        }, this);\n    },\n\n    allowsCall: function allowsCall(thisValue, args) {\n        var expectedArguments = this.expectedArguments;\n\n        if (this.met() && receivedMaxCalls(this)) {\n            return false;\n        }\n\n        if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n            return false;\n        }\n\n        if (!(\"expectedArguments\" in this)) {\n            return true;\n        }\n\n        args = args || [];\n\n        if (args.length < expectedArguments.length) {\n            return false;\n        }\n\n        if (this.expectsExactArgCount &&\n            args.length !== expectedArguments.length) {\n            return false;\n        }\n\n        return expectedArguments.every(function (expectedArgument, i) {\n            if (!verifyMatcher(expectedArgument, args[i])) {\n                return false;\n            }\n\n            if (!deepEqual(expectedArgument, args[i])) {\n                return false;\n            }\n\n            return true;\n        });\n    },\n\n    withArgs: function withArgs() {\n        this.expectedArguments = slice.call(arguments);\n        return this;\n    },\n\n    withExactArgs: function withExactArgs() {\n        this.withArgs.apply(this, arguments);\n        this.expectsExactArgCount = true;\n        return this;\n    },\n\n    on: function on(thisValue) {\n        this.expectedThis = thisValue;\n        return this;\n    },\n\n    toString: function () {\n        var args = (this.expectedArguments || []).slice();\n\n        if (!this.expectsExactArgCount) {\n            push.call(args, \"[...]\");\n        }\n\n        var callStr = spyCallToString.call({\n            proxy: this.method || \"anonymous mock expectation\",\n            args: args\n        });\n\n        var message = callStr.replace(\", [...\", \"[, ...\") + \" \" +\n            expectedCallCountInWords(this);\n\n        if (this.met()) {\n            return \"Expectation met: \" + message;\n        }\n\n        return \"Expected \" + message + \" (\" +\n            callCountInWords(this.callCount) + \")\";\n    },\n\n    verify: function verify() {\n        if (!this.met()) {\n            mockExpectation.fail(this.toString());\n        } else {\n            mockExpectation.pass(this.toString());\n        }\n\n        return true;\n    },\n\n    pass: function pass(message) {\n        assert.pass(message);\n    },\n\n    fail: function fail(message) {\n        var exception = new Error(message);\n        exception.name = \"ExpectationError\";\n\n        throw exception;\n    }\n};\n\nmodule.exports = mockExpectation;\n"]},"metadata":{},"sourceType":"script"}