{"ast":null,"code":"\"use strict\";\n\nvar fakeXhr = require(\"./fake_xml_http_request\");\n\nvar push = [].push;\n\nvar format = require(\"./core/format\");\n\nvar configureLogError = require(\"./core/log_error\");\n\nvar pathToRegexp = require(\"path-to-regexp\");\n\nfunction responseArray(handler) {\n  var response = handler;\n\n  if (Object.prototype.toString.call(handler) !== \"[object Array]\") {\n    response = [200, {}, handler];\n  }\n\n  if (typeof response[2] !== \"string\") {\n    throw new TypeError(\"Fake server response body should be string, but was \" + typeof response[2]);\n  }\n\n  return response;\n}\n\nfunction getDefaultWindowLocation() {\n  return {\n    \"host\": \"localhost\",\n    \"protocol\": \"http\"\n  };\n}\n\nfunction getWindowLocation() {\n  if (typeof window === \"undefined\") {\n    // Fallback\n    return getDefaultWindowLocation();\n  }\n\n  if (typeof window.location !== \"undefined\") {\n    // Browsers place location on window\n    return window.location;\n  }\n\n  if (typeof window.window !== \"undefined\" && typeof window.window.location !== \"undefined\") {\n    // React Native on Android places location on window.window\n    return window.window.location;\n  }\n\n  return getDefaultWindowLocation();\n}\n\nvar wloc = getWindowLocation();\nvar rCurrLoc = new RegExp(\"^\" + wloc.protocol + \"//\" + wloc.host);\n\nfunction matchOne(response, reqMethod, reqUrl) {\n  var rmeth = response.method;\n  var matchMethod = !rmeth || rmeth.toLowerCase() === reqMethod.toLowerCase();\n  var url = response.url;\n  var matchUrl = !url || url === reqUrl || typeof url.test === \"function\" && url.test(reqUrl);\n  return matchMethod && matchUrl;\n}\n\nfunction match(response, request) {\n  var requestUrl = request.url;\n\n  if (!/^https?:\\/\\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {\n    requestUrl = requestUrl.replace(rCurrLoc, \"\");\n  }\n\n  if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {\n    if (typeof response.response === \"function\") {\n      var ru = response.url;\n      var args = [request].concat(ru && typeof ru.exec === \"function\" ? ru.exec(requestUrl).slice(1) : []);\n      return response.response.apply(response, args);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction incrementRequestCount() {\n  var count = ++this.requestCount;\n  this.requested = true;\n  this.requestedOnce = count === 1;\n  this.requestedTwice = count === 2;\n  this.requestedThrice = count === 3;\n  this.firstRequest = this.getRequest(0);\n  this.secondRequest = this.getRequest(1);\n  this.thirdRequest = this.getRequest(2);\n  this.lastRequest = this.getRequest(count - 1);\n}\n\nvar fakeServer = {\n  create: function (config) {\n    var server = Object.create(this);\n    server.configure(config);\n    this.xhr = fakeXhr.useFakeXMLHttpRequest();\n    server.requests = [];\n    server.requestCount = 0;\n    server.queue = [];\n    server.responses = [];\n\n    this.xhr.onCreate = function (xhrObj) {\n      xhrObj.unsafeHeadersEnabled = function () {\n        return !(server.unsafeHeadersEnabled === false);\n      };\n\n      server.addRequest(xhrObj);\n    };\n\n    return server;\n  },\n  configure: function (config) {\n    var self = this;\n    var whitelist = {\n      \"autoRespond\": true,\n      \"autoRespondAfter\": true,\n      \"respondImmediately\": true,\n      \"fakeHTTPMethods\": true,\n      \"logger\": true,\n      \"unsafeHeadersEnabled\": true\n    };\n    config = config || {};\n    Object.keys(config).forEach(function (setting) {\n      if (setting in whitelist) {\n        self[setting] = config[setting];\n      }\n    });\n    self.logError = configureLogError(config);\n  },\n  addRequest: function addRequest(xhrObj) {\n    var server = this;\n    push.call(this.requests, xhrObj);\n    incrementRequestCount.call(this);\n\n    xhrObj.onSend = function () {\n      server.handleRequest(this);\n\n      if (server.respondImmediately) {\n        server.respond();\n      } else if (server.autoRespond && !server.responding) {\n        setTimeout(function () {\n          server.responding = false;\n          server.respond();\n        }, server.autoRespondAfter || 10);\n        server.responding = true;\n      }\n    };\n  },\n  getHTTPMethod: function getHTTPMethod(request) {\n    if (this.fakeHTTPMethods && /post/i.test(request.method)) {\n      var matches = (request.requestBody || \"\").match(/_method=([^\\b;]+)/);\n      return matches ? matches[1] : request.method;\n    }\n\n    return request.method;\n  },\n  handleRequest: function handleRequest(xhr) {\n    if (xhr.async) {\n      push.call(this.queue, xhr);\n    } else {\n      this.processRequest(xhr);\n    }\n  },\n  logger: function () {// no-op; override via configure()\n  },\n  logError: configureLogError({}),\n  log: function log(response, request) {\n    var str;\n    str = \"Request:\\n\" + format(request) + \"\\n\\n\";\n    str += \"Response:\\n\" + format(response) + \"\\n\\n\";\n\n    if (typeof this.logger === \"function\") {\n      this.logger(str);\n    }\n  },\n  respondWith: function respondWith(method, url, body) {\n    if (arguments.length === 1 && typeof method !== \"function\") {\n      this.response = responseArray(method);\n      return;\n    }\n\n    if (arguments.length === 1) {\n      body = method;\n      url = method = null;\n    }\n\n    if (arguments.length === 2) {\n      body = url;\n      url = method;\n      method = null;\n    }\n\n    push.call(this.responses, {\n      method: method,\n      url: typeof url === \"string\" && url !== \"\" ? pathToRegexp(url) : url,\n      response: typeof body === \"function\" ? body : responseArray(body)\n    });\n  },\n  respond: function respond() {\n    if (arguments.length > 0) {\n      this.respondWith.apply(this, arguments);\n    }\n\n    var queue = this.queue || [];\n    var requests = queue.splice(0, queue.length);\n    var self = this;\n    requests.forEach(function (request) {\n      self.processRequest(request);\n    });\n  },\n  processRequest: function processRequest(request) {\n    try {\n      if (request.aborted) {\n        return;\n      }\n\n      var response = this.response || [404, {}, \"\"];\n\n      if (this.responses) {\n        for (var l = this.responses.length, i = l - 1; i >= 0; i--) {\n          if (match.call(this, this.responses[i], request)) {\n            response = this.responses[i].response;\n            break;\n          }\n        }\n      }\n\n      if (request.readyState !== 4) {\n        this.log(response, request);\n        request.respond(response[0], response[1], response[2]);\n      }\n    } catch (e) {\n      this.logError(\"Fake server request processing\", e);\n    }\n  },\n  restore: function restore() {\n    return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);\n  },\n  getRequest: function getRequest(index) {\n    return this.requests[index] || null;\n  },\n  reset: function reset() {\n    this.resetBehavior();\n    this.resetHistory();\n  },\n  resetBehavior: function resetBehavior() {\n    this.responses.length = this.queue.length = 0;\n  },\n  resetHistory: function resetHistory() {\n    this.requests.length = this.requestCount = 0;\n    this.requestedOnce = this.requestedTwice = this.requestedThrice = this.requested = false;\n    this.firstRequest = this.secondRequest = this.thirdRequest = this.lastRequest = null;\n  }\n};\nmodule.exports = fakeServer;","map":{"version":3,"sources":["/home/hoss/my App/my-app/node_modules/sinon/lib/sinon/util/fake_server.js"],"names":["fakeXhr","require","push","format","configureLogError","pathToRegexp","responseArray","handler","response","Object","prototype","toString","call","TypeError","getDefaultWindowLocation","getWindowLocation","window","location","wloc","rCurrLoc","RegExp","protocol","host","matchOne","reqMethod","reqUrl","rmeth","method","matchMethod","toLowerCase","url","matchUrl","test","match","request","requestUrl","replace","getHTTPMethod","ru","args","concat","exec","slice","apply","incrementRequestCount","count","requestCount","requested","requestedOnce","requestedTwice","requestedThrice","firstRequest","getRequest","secondRequest","thirdRequest","lastRequest","fakeServer","create","config","server","configure","xhr","useFakeXMLHttpRequest","requests","queue","responses","onCreate","xhrObj","unsafeHeadersEnabled","addRequest","self","whitelist","keys","forEach","setting","logError","onSend","handleRequest","respondImmediately","respond","autoRespond","responding","setTimeout","autoRespondAfter","fakeHTTPMethods","matches","requestBody","async","processRequest","logger","log","str","respondWith","body","arguments","length","splice","aborted","l","i","readyState","e","restore","index","reset","resetBehavior","resetHistory","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar fakeXhr = require(\"./fake_xml_http_request\");\nvar push = [].push;\nvar format = require(\"./core/format\");\nvar configureLogError = require(\"./core/log_error\");\nvar pathToRegexp = require(\"path-to-regexp\");\n\nfunction responseArray(handler) {\n    var response = handler;\n\n    if (Object.prototype.toString.call(handler) !== \"[object Array]\") {\n        response = [200, {}, handler];\n    }\n\n    if (typeof response[2] !== \"string\") {\n        throw new TypeError(\"Fake server response body should be string, but was \" +\n                            typeof response[2]);\n    }\n\n    return response;\n}\n\nfunction getDefaultWindowLocation() {\n    return { \"host\": \"localhost\", \"protocol\": \"http\" };\n}\n\nfunction getWindowLocation() {\n    if (typeof window === \"undefined\") {\n        // Fallback\n        return getDefaultWindowLocation();\n    }\n\n    if (typeof window.location !== \"undefined\") {\n        // Browsers place location on window\n        return window.location;\n    }\n\n    if ((typeof window.window !== \"undefined\") && (typeof window.window.location !== \"undefined\")) {\n        // React Native on Android places location on window.window\n        return window.window.location;\n    }\n\n    return getDefaultWindowLocation();\n}\n\nvar wloc = getWindowLocation();\n\nvar rCurrLoc = new RegExp(\"^\" + wloc.protocol + \"//\" + wloc.host);\n\nfunction matchOne(response, reqMethod, reqUrl) {\n    var rmeth = response.method;\n    var matchMethod = !rmeth || rmeth.toLowerCase() === reqMethod.toLowerCase();\n    var url = response.url;\n    var matchUrl = !url || url === reqUrl || (typeof url.test === \"function\" && url.test(reqUrl));\n\n    return matchMethod && matchUrl;\n}\n\nfunction match(response, request) {\n    var requestUrl = request.url;\n\n    if (!/^https?:\\/\\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {\n        requestUrl = requestUrl.replace(rCurrLoc, \"\");\n    }\n\n    if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {\n        if (typeof response.response === \"function\") {\n            var ru = response.url;\n            var args = [request].concat(ru && typeof ru.exec === \"function\" ? ru.exec(requestUrl).slice(1) : []);\n            return response.response.apply(response, args);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nfunction incrementRequestCount() {\n    var count = ++this.requestCount;\n\n    this.requested = true;\n\n    this.requestedOnce = count === 1;\n    this.requestedTwice = count === 2;\n    this.requestedThrice = count === 3;\n\n    this.firstRequest = this.getRequest(0);\n    this.secondRequest = this.getRequest(1);\n    this.thirdRequest = this.getRequest(2);\n\n    this.lastRequest = this.getRequest(count - 1);\n}\n\nvar fakeServer = {\n    create: function (config) {\n        var server = Object.create(this);\n        server.configure(config);\n        this.xhr = fakeXhr.useFakeXMLHttpRequest();\n        server.requests = [];\n        server.requestCount = 0;\n        server.queue = [];\n        server.responses = [];\n\n\n        this.xhr.onCreate = function (xhrObj) {\n            xhrObj.unsafeHeadersEnabled = function () {\n                return !(server.unsafeHeadersEnabled === false);\n            };\n            server.addRequest(xhrObj);\n        };\n\n        return server;\n    },\n\n    configure: function (config) {\n        var self = this;\n        var whitelist = {\n            \"autoRespond\": true,\n            \"autoRespondAfter\": true,\n            \"respondImmediately\": true,\n            \"fakeHTTPMethods\": true,\n            \"logger\": true,\n            \"unsafeHeadersEnabled\": true\n        };\n\n        config = config || {};\n\n        Object.keys(config).forEach(function (setting) {\n            if (setting in whitelist) {\n                self[setting] = config[setting];\n            }\n        });\n\n        self.logError = configureLogError(config);\n    },\n\n    addRequest: function addRequest(xhrObj) {\n        var server = this;\n        push.call(this.requests, xhrObj);\n\n        incrementRequestCount.call(this);\n\n        xhrObj.onSend = function () {\n            server.handleRequest(this);\n\n            if (server.respondImmediately) {\n                server.respond();\n            } else if (server.autoRespond && !server.responding) {\n                setTimeout(function () {\n                    server.responding = false;\n                    server.respond();\n                }, server.autoRespondAfter || 10);\n\n                server.responding = true;\n            }\n        };\n    },\n\n    getHTTPMethod: function getHTTPMethod(request) {\n        if (this.fakeHTTPMethods && /post/i.test(request.method)) {\n            var matches = (request.requestBody || \"\").match(/_method=([^\\b;]+)/);\n            return matches ? matches[1] : request.method;\n        }\n\n        return request.method;\n    },\n\n    handleRequest: function handleRequest(xhr) {\n        if (xhr.async) {\n            push.call(this.queue, xhr);\n        } else {\n            this.processRequest(xhr);\n        }\n    },\n\n    logger: function () {\n        // no-op; override via configure()\n    },\n\n    logError: configureLogError({}),\n\n    log: function log(response, request) {\n        var str;\n\n        str = \"Request:\\n\" + format(request) + \"\\n\\n\";\n        str += \"Response:\\n\" + format(response) + \"\\n\\n\";\n\n        if (typeof this.logger === \"function\") {\n            this.logger(str);\n        }\n    },\n\n    respondWith: function respondWith(method, url, body) {\n        if (arguments.length === 1 && typeof method !== \"function\") {\n            this.response = responseArray(method);\n            return;\n        }\n\n        if (arguments.length === 1) {\n            body = method;\n            url = method = null;\n        }\n\n        if (arguments.length === 2) {\n            body = url;\n            url = method;\n            method = null;\n        }\n\n        push.call(this.responses, {\n            method: method,\n            url: typeof url === \"string\" && url !== \"\" ? pathToRegexp(url) : url,\n            response: typeof body === \"function\" ? body : responseArray(body)\n        });\n    },\n\n    respond: function respond() {\n        if (arguments.length > 0) {\n            this.respondWith.apply(this, arguments);\n        }\n\n        var queue = this.queue || [];\n        var requests = queue.splice(0, queue.length);\n        var self = this;\n\n        requests.forEach(function (request) {\n            self.processRequest(request);\n        });\n    },\n\n    processRequest: function processRequest(request) {\n        try {\n            if (request.aborted) {\n                return;\n            }\n\n            var response = this.response || [404, {}, \"\"];\n\n            if (this.responses) {\n                for (var l = this.responses.length, i = l - 1; i >= 0; i--) {\n                    if (match.call(this, this.responses[i], request)) {\n                        response = this.responses[i].response;\n                        break;\n                    }\n                }\n            }\n\n            if (request.readyState !== 4) {\n                this.log(response, request);\n\n                request.respond(response[0], response[1], response[2]);\n            }\n        } catch (e) {\n            this.logError(\"Fake server request processing\", e);\n        }\n    },\n\n    restore: function restore() {\n        return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);\n    },\n\n    getRequest: function getRequest(index) {\n        return this.requests[index] || null;\n    },\n\n    reset: function reset() {\n        this.resetBehavior();\n        this.resetHistory();\n    },\n\n    resetBehavior: function resetBehavior() {\n        this.responses.length = this.queue.length = 0;\n    },\n\n    resetHistory: function resetHistory() {\n        this.requests.length = this.requestCount = 0;\n\n        this.requestedOnce = this.requestedTwice = this.requestedThrice = this.requested = false;\n\n        this.firstRequest = this.secondRequest = this.thirdRequest = this.lastRequest = null;\n    }\n};\n\nmodule.exports = fakeServer;\n"]},"metadata":{},"sourceType":"script"}