{"ast":null,"code":"\"use strict\";\n\nvar calledInOrder = require(\"./util/core/called-in-order\");\n\nvar orderByFirstCall = require(\"./util/core/order-by-first-call\");\n\nvar timesInWords = require(\"./util/core/times-in-words\");\n\nvar format = require(\"./util/core/format\");\n\nvar sinonMatch = require(\"./match\");\n\nvar slice = Array.prototype.slice;\nvar assert;\n\nfunction verifyIsStub() {\n  var args = Array.prototype.slice.call(arguments);\n  args.forEach(function (method) {\n    if (!method) {\n      assert.fail(\"fake is not a spy\");\n    }\n\n    if (method.proxy && method.proxy.isSinonProxy) {\n      verifyIsStub(method.proxy);\n    } else {\n      if (typeof method !== \"function\") {\n        assert.fail(method + \" is not a function\");\n      }\n\n      if (typeof method.getCall !== \"function\") {\n        assert.fail(method + \" is not stubbed\");\n      }\n    }\n  });\n}\n\nfunction verifyIsValidAssertion(assertionMethod, assertionArgs) {\n  switch (assertionMethod) {\n    case \"notCalled\":\n    case \"called\":\n    case \"calledOnce\":\n    case \"calledTwice\":\n    case \"calledThrice\":\n      if (assertionArgs.length !== 0) {\n        assert.fail(assertionMethod + \" takes 1 argument but was called with \" + (assertionArgs.length + 1) + \" arguments\");\n      }\n\n      break;\n\n    default:\n      break;\n  }\n}\n\nfunction failAssertion(object, msg) {\n  object = object || global;\n  var failMethod = object.fail || assert.fail;\n  failMethod.call(object, msg);\n}\n\nfunction mirrorPropAsAssertion(name, method, message) {\n  if (arguments.length === 2) {\n    message = method;\n    method = name;\n  }\n\n  assert[name] = function (fake) {\n    verifyIsStub(fake);\n    var args = slice.call(arguments, 1);\n    var failed = false;\n    verifyIsValidAssertion(name, args);\n\n    if (typeof method === \"function\") {\n      failed = !method(fake);\n    } else {\n      failed = typeof fake[method] === \"function\" ? !fake[method].apply(fake, args) : !fake[method];\n    }\n\n    if (failed) {\n      failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, [message].concat(args)));\n    } else {\n      assert.pass(name);\n    }\n  };\n}\n\nfunction exposedName(prefix, prop) {\n  return !prefix || /^fail/.test(prop) ? prop : prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);\n}\n\nassert = {\n  failException: \"AssertError\",\n  fail: function fail(message) {\n    var error = new Error(message);\n    error.name = this.failException || assert.failException;\n    throw error;\n  },\n  pass: function pass() {},\n  callOrder: function assertCallOrder() {\n    verifyIsStub.apply(null, arguments);\n    var expected = \"\";\n    var actual = \"\";\n\n    if (!calledInOrder(arguments)) {\n      try {\n        expected = [].join.call(arguments, \", \");\n        var calls = slice.call(arguments);\n        var i = calls.length;\n\n        while (i) {\n          if (!calls[--i].called) {\n            calls.splice(i, 1);\n          }\n        }\n\n        actual = orderByFirstCall(calls).join(\", \");\n      } catch (e) {// If this fails, we'll just fall back to the blank string\n      }\n\n      failAssertion(this, \"expected \" + expected + \" to be \" + \"called in order but were called as \" + actual);\n    } else {\n      assert.pass(\"callOrder\");\n    }\n  },\n  callCount: function assertCallCount(method, count) {\n    verifyIsStub(method);\n\n    if (method.callCount !== count) {\n      var msg = \"expected %n to be called \" + timesInWords(count) + \" but was called %c%C\";\n      failAssertion(this, method.printf(msg));\n    } else {\n      assert.pass(\"callCount\");\n    }\n  },\n  expose: function expose(target, options) {\n    if (!target) {\n      throw new TypeError(\"target is null or undefined\");\n    }\n\n    var o = options || {};\n    var prefix = typeof o.prefix === \"undefined\" && \"assert\" || o.prefix;\n    var includeFail = typeof o.includeFail === \"undefined\" || !!o.includeFail;\n    var instance = this;\n    Object.keys(instance).forEach(function (method) {\n      if (method !== \"expose\" && (includeFail || !/^(fail)/.test(method))) {\n        target[exposedName(prefix, method)] = instance[method];\n      }\n    });\n    return target;\n  },\n  match: function match(actual, expectation) {\n    var matcher = sinonMatch(expectation);\n\n    if (matcher.test(actual)) {\n      assert.pass(\"match\");\n    } else {\n      var formatted = [\"expected value to match\", \"    expected = \" + format(expectation), \"    actual = \" + format(actual)];\n      failAssertion(this, formatted.join(\"\\n\"));\n    }\n  }\n};\nmirrorPropAsAssertion(\"called\", \"expected %n to have been called at least once but was never called\");\nmirrorPropAsAssertion(\"notCalled\", function (spy) {\n  return !spy.called;\n}, \"expected %n to not have been called but was called %c%C\");\nmirrorPropAsAssertion(\"calledOnce\", \"expected %n to be called once but was called %c%C\");\nmirrorPropAsAssertion(\"calledTwice\", \"expected %n to be called twice but was called %c%C\");\nmirrorPropAsAssertion(\"calledThrice\", \"expected %n to be called thrice but was called %c%C\");\nmirrorPropAsAssertion(\"calledOn\", \"expected %n to be called with %1 as this but was called with %t\");\nmirrorPropAsAssertion(\"alwaysCalledOn\", \"expected %n to always be called with %1 as this but was called with %t\");\nmirrorPropAsAssertion(\"calledWithNew\", \"expected %n to be called with new\");\nmirrorPropAsAssertion(\"alwaysCalledWithNew\", \"expected %n to always be called with new\");\nmirrorPropAsAssertion(\"calledWith\", \"expected %n to be called with arguments %D\");\nmirrorPropAsAssertion(\"calledWithMatch\", \"expected %n to be called with match %D\");\nmirrorPropAsAssertion(\"alwaysCalledWith\", \"expected %n to always be called with arguments %D\");\nmirrorPropAsAssertion(\"alwaysCalledWithMatch\", \"expected %n to always be called with match %D\");\nmirrorPropAsAssertion(\"calledWithExactly\", \"expected %n to be called with exact arguments %D\");\nmirrorPropAsAssertion(\"alwaysCalledWithExactly\", \"expected %n to always be called with exact arguments %D\");\nmirrorPropAsAssertion(\"neverCalledWith\", \"expected %n to never be called with arguments %*%C\");\nmirrorPropAsAssertion(\"neverCalledWithMatch\", \"expected %n to never be called with match %*%C\");\nmirrorPropAsAssertion(\"threw\", \"%n did not throw exception%C\");\nmirrorPropAsAssertion(\"alwaysThrew\", \"%n did not always throw exception%C\");\nmodule.exports = assert;","map":{"version":3,"sources":["/home/hoss/my App/my-app/node_modules/sinon/lib/sinon/assert.js"],"names":["calledInOrder","require","orderByFirstCall","timesInWords","format","sinonMatch","slice","Array","prototype","assert","verifyIsStub","args","call","arguments","forEach","method","fail","proxy","isSinonProxy","getCall","verifyIsValidAssertion","assertionMethod","assertionArgs","length","failAssertion","object","msg","global","failMethod","mirrorPropAsAssertion","name","message","fake","failed","apply","printf","concat","pass","exposedName","prefix","prop","test","toUpperCase","failException","error","Error","callOrder","assertCallOrder","expected","actual","join","calls","i","called","splice","e","callCount","assertCallCount","count","expose","target","options","TypeError","o","includeFail","instance","Object","keys","match","expectation","matcher","formatted","spy","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar calledInOrder = require(\"./util/core/called-in-order\");\nvar orderByFirstCall = require(\"./util/core/order-by-first-call\");\nvar timesInWords = require(\"./util/core/times-in-words\");\nvar format = require(\"./util/core/format\");\nvar sinonMatch = require(\"./match\");\n\nvar slice = Array.prototype.slice;\n\nvar assert;\n\nfunction verifyIsStub() {\n    var args = Array.prototype.slice.call(arguments);\n\n    args.forEach(function (method) {\n        if (!method) {\n            assert.fail(\"fake is not a spy\");\n        }\n\n        if (method.proxy && method.proxy.isSinonProxy) {\n            verifyIsStub(method.proxy);\n        } else {\n            if (typeof method !== \"function\") {\n                assert.fail(method + \" is not a function\");\n            }\n\n            if (typeof method.getCall !== \"function\") {\n                assert.fail(method + \" is not stubbed\");\n            }\n        }\n    });\n}\n\nfunction verifyIsValidAssertion(assertionMethod, assertionArgs) {\n    switch (assertionMethod) {\n        case \"notCalled\":\n        case \"called\":\n        case \"calledOnce\":\n        case \"calledTwice\":\n        case \"calledThrice\":\n            if (assertionArgs.length !== 0) {\n                assert.fail(assertionMethod +\n                            \" takes 1 argument but was called with \" + (assertionArgs.length + 1) + \" arguments\");\n            }\n            break;\n        default:\n            break;\n    }\n}\n\nfunction failAssertion(object, msg) {\n    object = object || global;\n    var failMethod = object.fail || assert.fail;\n    failMethod.call(object, msg);\n}\n\nfunction mirrorPropAsAssertion(name, method, message) {\n    if (arguments.length === 2) {\n        message = method;\n        method = name;\n    }\n\n    assert[name] = function (fake) {\n        verifyIsStub(fake);\n\n        var args = slice.call(arguments, 1);\n        var failed = false;\n\n        verifyIsValidAssertion(name, args);\n\n        if (typeof method === \"function\") {\n            failed = !method(fake);\n        } else {\n            failed = typeof fake[method] === \"function\" ?\n                !fake[method].apply(fake, args) : !fake[method];\n        }\n\n        if (failed) {\n            failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, [message].concat(args)));\n        } else {\n            assert.pass(name);\n        }\n    };\n}\n\nfunction exposedName(prefix, prop) {\n    return !prefix || /^fail/.test(prop) ? prop :\n        prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);\n}\n\nassert = {\n    failException: \"AssertError\",\n\n    fail: function fail(message) {\n        var error = new Error(message);\n        error.name = this.failException || assert.failException;\n\n        throw error;\n    },\n\n    pass: function pass() {},\n\n    callOrder: function assertCallOrder() {\n        verifyIsStub.apply(null, arguments);\n        var expected = \"\";\n        var actual = \"\";\n\n        if (!calledInOrder(arguments)) {\n            try {\n                expected = [].join.call(arguments, \", \");\n                var calls = slice.call(arguments);\n                var i = calls.length;\n                while (i) {\n                    if (!calls[--i].called) {\n                        calls.splice(i, 1);\n                    }\n                }\n                actual = orderByFirstCall(calls).join(\", \");\n            } catch (e) {\n                // If this fails, we'll just fall back to the blank string\n            }\n\n            failAssertion(this, \"expected \" + expected + \" to be \" +\n                        \"called in order but were called as \" + actual);\n        } else {\n            assert.pass(\"callOrder\");\n        }\n    },\n\n    callCount: function assertCallCount(method, count) {\n        verifyIsStub(method);\n\n        if (method.callCount !== count) {\n            var msg = \"expected %n to be called \" + timesInWords(count) +\n                \" but was called %c%C\";\n            failAssertion(this, method.printf(msg));\n        } else {\n            assert.pass(\"callCount\");\n        }\n    },\n\n    expose: function expose(target, options) {\n        if (!target) {\n            throw new TypeError(\"target is null or undefined\");\n        }\n\n        var o = options || {};\n        var prefix = typeof o.prefix === \"undefined\" && \"assert\" || o.prefix;\n        var includeFail = typeof o.includeFail === \"undefined\" || !!o.includeFail;\n        var instance = this;\n\n        Object.keys(instance).forEach(function (method) {\n            if (method !== \"expose\" && (includeFail || !/^(fail)/.test(method))) {\n                target[exposedName(prefix, method)] = instance[method];\n            }\n        });\n\n        return target;\n    },\n\n    match: function match(actual, expectation) {\n        var matcher = sinonMatch(expectation);\n        if (matcher.test(actual)) {\n            assert.pass(\"match\");\n        } else {\n            var formatted = [\n                \"expected value to match\",\n                \"    expected = \" + format(expectation),\n                \"    actual = \" + format(actual)\n            ];\n\n            failAssertion(this, formatted.join(\"\\n\"));\n        }\n    }\n};\n\nmirrorPropAsAssertion(\"called\", \"expected %n to have been called at least once but was never called\");\nmirrorPropAsAssertion(\"notCalled\", function (spy) {\n    return !spy.called;\n}, \"expected %n to not have been called but was called %c%C\");\nmirrorPropAsAssertion(\"calledOnce\", \"expected %n to be called once but was called %c%C\");\nmirrorPropAsAssertion(\"calledTwice\", \"expected %n to be called twice but was called %c%C\");\nmirrorPropAsAssertion(\"calledThrice\", \"expected %n to be called thrice but was called %c%C\");\nmirrorPropAsAssertion(\"calledOn\", \"expected %n to be called with %1 as this but was called with %t\");\nmirrorPropAsAssertion(\n    \"alwaysCalledOn\",\n    \"expected %n to always be called with %1 as this but was called with %t\"\n);\nmirrorPropAsAssertion(\"calledWithNew\", \"expected %n to be called with new\");\nmirrorPropAsAssertion(\"alwaysCalledWithNew\", \"expected %n to always be called with new\");\nmirrorPropAsAssertion(\"calledWith\", \"expected %n to be called with arguments %D\");\nmirrorPropAsAssertion(\"calledWithMatch\", \"expected %n to be called with match %D\");\nmirrorPropAsAssertion(\"alwaysCalledWith\", \"expected %n to always be called with arguments %D\");\nmirrorPropAsAssertion(\"alwaysCalledWithMatch\", \"expected %n to always be called with match %D\");\nmirrorPropAsAssertion(\"calledWithExactly\", \"expected %n to be called with exact arguments %D\");\nmirrorPropAsAssertion(\"alwaysCalledWithExactly\", \"expected %n to always be called with exact arguments %D\");\nmirrorPropAsAssertion(\"neverCalledWith\", \"expected %n to never be called with arguments %*%C\");\nmirrorPropAsAssertion(\"neverCalledWithMatch\", \"expected %n to never be called with match %*%C\");\nmirrorPropAsAssertion(\"threw\", \"%n did not throw exception%C\");\nmirrorPropAsAssertion(\"alwaysThrew\", \"%n did not always throw exception%C\");\n\nmodule.exports = assert;\n"]},"metadata":{},"sourceType":"script"}