{"ast":null,"code":"const assert = require('./assert.js');\n\nconst nodeStore = require('./nodeStore.js'); // Initial Call, checks to make sure this is not a router application which is not supported yet\n\n\nconst parser = (dom, reactDom) => {\n  if (dom._reactInternalInstance._context.router) return 'reactRouter';\n  return ReactParentTraverse(dom);\n}; // The nodestore collects all relevant information such as ids, classes of the page in an object\n\n\nconst nodeStoreController = (node, name, address, props, state, parent = false) => {\n  nodeStore.storage.address[address] = {};\n  nodeStore.storage.address[address].state = state;\n  nodeStore.storage.address[address].props = props;\n  nodeStore.storage.address[address].name = name;\n  let classArr; // Here we seperate out logic based on the type of component we are working on\n\n  if (node.constructor.name === 'ReactDOMComponent') {\n    // Setting id for item\n    if (props.id) nodeStore.storage.id[props.id] = address; // Setting classes for item\n\n    if (props.className) {\n      classArr = props.className.split(/\\s+/);\n      classArr.forEach(newclass => {\n        if (nodeStore.storage.class[newclass]) nodeStore.storage.class[newclass].push(address);else nodeStore.storage.class[newclass] = [address];\n      });\n    } // Storing the tag of the node\n\n\n    nodeStore.storage.tag[name] ? nodeStore.storage.tag[name].push(address) : nodeStore.storage.tag[name] = [address]; // Storing the index of the item in case we need to reference it out of a group selection. \n\n    nodeStore.storage.address[address].index = nodeStore.storage.tag[name].length - 1; // This logic will cover smart components\n  } else {\n    // We store props, state, and address about the node here\n    if (nodeStore.storage.node[name]) {\n      nodeStore.storage.node[name].address.push(address);\n      nodeStore.storage.node[name].state.push(state);\n      nodeStore.storage.node[name].props.push(props);\n    } else {\n      nodeStore.storage.node[name] = {};\n      nodeStore.storage.node[name].address = [address];\n      nodeStore.storage.node[name].state = [state];\n      nodeStore.storage.node[name].props = [props];\n    } // Index of item in case we need to reference it based on a group selection\n\n\n    nodeStore.storage.address[address].index = nodeStore.storage.node[name].address.length - 1; // Some special logic based on whether or not this component is the root component or not\n    // This is for non parent nodes\n\n    if (!parent) {\n      // Setting node id\n      if (node._renderedComponent._hostNode.id) nodeStore.storage.id[node._renderedComponent._hostNode.id] = address; // Setting node classes\n\n      if (node._renderedComponent._hostNode.className) {\n        classArr = node._renderedComponent._hostNode.className.split(/\\s+/);\n        classArr.forEach(item => {\n          if (nodeStore.storage.class[item]) nodeStore.storage.class[item].push(address);else nodeStore.storage.class[item] = [address];\n        });\n      } // Logic for parent component\n\n    } else {\n      // Setting node id\n      if (node._reactInternalInstance._renderedComponent._hostContainerInfo._node.id) nodeStore.storage.id[node._reactInternalInstance._renderedComponent._hostContainerInfo._node.id] = address; // Setting node classes\n\n      if (node._reactInternalInstance._renderedComponent._hostContainerInfo._node.className) {\n        classArr = node._reactInternalInstance._renderedComponent._hostContainerInfo._node.className.split(/\\s+/);\n        classArr.forEach(item => {\n          if (nodeStore.storage.class[item]) nodeStore.storage.class[item].push(address);else nodeStore.storage.class[item] = [address];\n        });\n      }\n    }\n  }\n};\n\nconst ReactParentTraverse = dom => {\n  // Resets the nodeStore for the new traverse\n  nodeStore.storage = {\n    address: {},\n    id: {},\n    class: {},\n    node: {},\n    tag: {}\n  }; // Create a new data object to fill with our parsed DOM. \n\n  const data = {}; // Target parent name\n\n  data.name = dom.constructor.name; // Parent is automatically a smart component, so this is set to true\n\n  data.component = true; // Setting parent props\n\n  data.props = dom.props; // Setting parent state \n\n  data.state = dom.state; // Setting parent address\n\n  data.address = [dom._reactInternalInstance._hostContainerInfo._node.id, 0]; // Setting parent id\n\n  data.id = dom._reactInternalInstance._renderedComponent._hostContainerInfo._node.id; // Setting parent class\n\n  data.class = dom._reactInternalInstance._renderedComponent._hostContainerInfo._node.className; // Add necessary data to nodeStore\n\n  nodeStoreController(dom, data.name, data.address, data.props, data.state, true); // Instantiate the children array for the parent node\n\n  data.children = []; // Setting debugId of parent node to -1. Not sure if React ever uses 0. \n\n  data.debugId = -1; // make call to another function where it will traverse through children\n\n  const children = dom._reactInternalInstance._renderedComponent._renderedChildren;\n\n  if (children) {\n    Object.values(children).forEach((child, index) => {\n      const address = data.address.slice(0);\n      address.push(index); // Here we start our recursion through the virtual DOM\n\n      if (child.constructor.name !== 'ReactDOMTextComponent') data.children.push(ReactChildTraverse(child, address));\n    });\n  } // At this point we've finished all of our recursive calls to ReactChildTraverse\n  // So we now check our asserts\n\n\n  assert.checkAssert(); // and return the data we collected\n\n  return data;\n}; // Our traversal function for every node but the root node\n\n\nconst ReactChildTraverse = (child, address) => {\n  // We declare the object we will be building, starting it with an empty children array\n  const childData = {\n    children: []\n  };\n  let children;\n  let props;\n  childData.debugId = child._debugID; // set conditional for component vs not\n\n  if (child.constructor.name === 'ReactCompositeComponentWrapper') {\n    // Parsing logic for smart React Components\n    childData.name = child._currentElement.type.name;\n    childData.component = true; // We clone the state to ensure no circular references\n\n    childData.state = cloneDeep(child._instance.state); // If props exist, make a copy of it so we can delete children out of it, otherwise it's null\n\n    let newProps = child._instance.props !== null ? Object.assign({}, child._instance.props) : null; // Delete children out of props \n\n    if (newProps.children) delete newProps.children; // Set our props to a cloned version of the props\n\n    childData.props = cloneDeep(newProps); // Get references to the node's children\n\n    children = child._renderedComponent._renderedChildren; // Set address, it's either the node's id or the address passed down to the node\n\n    childData.address = child._renderedComponent._hostNode.id ? [child._renderedComponent._hostNode.id] : address; // Set node's id \n\n    childData.id = child._renderedComponent._hostNode.id; // Set node's class\n\n    childData.class = child._renderedComponent._hostNode.className;\n  } else {\n    // Parsing logic for dumb React Components\n    // See above comments if you need to see what is happening here, same logic, different locations\n    childData.name = child._currentElement.type;\n    childData.component = false;\n    childData.state = null;\n    childData.address = child._currentElement.props.id ? [child._currentElement.props.id] : address;\n    var newProps = child._currentElement.props !== null ? Object.assign({}, child._currentElement.props) : null;\n    if (newProps.children) delete newProps.children;\n    childData.props = cloneDeep(newProps);\n    childData.id = childData.props.id;\n    childData.class = childData.props.className;\n    children = child._renderedChildren;\n  } // We add the info we've collected for our node to the nodeStore\n\n\n  nodeStoreController(child, childData.name, childData.address, childData.props, childData.state); // If we have children, set up our recursive calls\n\n  if (children) {\n    let textNodes = 0;\n    Object.values(children).forEach((child, index) => {\n      // Filter out all React Text Nodes\n      // We may want to add the text data to the parent node on a future revision\n      if (child.constructor.name === 'ReactDOMTextComponent') {\n        textNodes++;\n      } else {\n        // create new Address to pass on to children in recursive call\n        let newAddress = childData.address.slice(0); // Text nodes offset our address algorithm, so we subtract them from our address index to ensure consistency\n\n        newAddress.push(index - textNodes); // We populate our children array with the results of further recursive calls to the object's children\n\n        childData.children.push(ReactChildTraverse(child, newAddress));\n      }\n    });\n  } // Delete id and className from props as to not have confusion on the frontend\n\n\n  if (childData.props.id) delete childData.props.id;\n  if (childData.props.className) delete childData.props.className;\n  return childData;\n}; // Creates a clone of an object/array and also clones any objects/arrays that may be nested inside of it\n\n\nfunction cloneDeep(value) {\n  if (!(value instanceof Object)) return value;\n  const result = new value.constructor();\n\n  if (value.constructor === Array) {\n    value.forEach(item => result.push(cloneDeep(item)));\n  } else if (typeof value === 'function') {\n    return 'function';\n  } else {\n    for (let key in value) {\n      result[key] = cloneDeep(value[key]);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  parser\n};","map":{"version":3,"sources":["/home/hoss/my App/my-app/node_modules/react-vt/src/dom-parse.js"],"names":["assert","require","nodeStore","parser","dom","reactDom","_reactInternalInstance","_context","router","ReactParentTraverse","nodeStoreController","node","name","address","props","state","parent","storage","classArr","constructor","id","className","split","forEach","newclass","class","push","tag","index","length","_renderedComponent","_hostNode","item","_hostContainerInfo","_node","data","component","children","debugId","_renderedChildren","Object","values","child","slice","ReactChildTraverse","checkAssert","childData","_debugID","_currentElement","type","cloneDeep","_instance","newProps","assign","textNodes","newAddress","value","result","Array","key","module","exports"],"mappings":"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","sourcesContent":["const assert = require('./assert.js');\nconst nodeStore = require('./nodeStore.js');\n\n\n// Initial Call, checks to make sure this is not a router application which is not supported yet\nconst parser = (dom, reactDom) => {\n  if (dom._reactInternalInstance._context.router) return 'reactRouter';\n  return ReactParentTraverse(dom);\n};\n\n\n// The nodestore collects all relevant information such as ids, classes of the page in an object\nconst nodeStoreController = (node, name, address, props, state, parent = false) => {\n  nodeStore.storage.address[address] = {};\n  nodeStore.storage.address[address].state = state;\n  nodeStore.storage.address[address].props = props;\n  nodeStore.storage.address[address].name = name;\n  let classArr;  \n\n  // Here we seperate out logic based on the type of component we are working on\n  if (node.constructor.name === 'ReactDOMComponent') {\n    // Setting id for item\n    if (props.id) nodeStore.storage.id[props.id] = address; \n\n    // Setting classes for item\n    if (props.className) {\n      classArr = props.className.split(/\\s+/);\n      classArr.forEach(newclass => {\n        if (nodeStore.storage.class[newclass]) nodeStore.storage.class[newclass].push(address)\n        else nodeStore.storage.class[newclass] = [address];\n      });\n    }\n    \n    // Storing the tag of the node\n    nodeStore.storage.tag[name] ? nodeStore.storage.tag[name].push(address) : nodeStore.storage.tag[name] = [address];\n    \n    // Storing the index of the item in case we need to reference it out of a group selection. \n    nodeStore.storage.address[address].index = nodeStore.storage.tag[name].length - 1; \n\n  // This logic will cover smart components\n  } else {\n \n    // We store props, state, and address about the node here\n    if (nodeStore.storage.node[name]) {\n      nodeStore.storage.node[name].address.push(address);\n      nodeStore.storage.node[name].state.push(state);\n      nodeStore.storage.node[name].props.push(props);\n\n    } else {\n      nodeStore.storage.node[name] = {};\n      nodeStore.storage.node[name].address = [address];\n      nodeStore.storage.node[name].state = [state];\n      nodeStore.storage.node[name].props = [props];\n    }\n\n    // Index of item in case we need to reference it based on a group selection\n    nodeStore.storage.address[address].index = nodeStore.storage.node[name].address.length - 1;\n\n    // Some special logic based on whether or not this component is the root component or not\n    // This is for non parent nodes\n    if (!parent) {\n      // Setting node id\n      if (node._renderedComponent._hostNode.id) nodeStore.storage.id[node._renderedComponent._hostNode.id] = address;\n      // Setting node classes\n      if (node._renderedComponent._hostNode.className) {\n        classArr = node._renderedComponent._hostNode.className.split(/\\s+/);\n        classArr.forEach(item => {\n          if (nodeStore.storage.class[item]) nodeStore.storage.class[item].push(address)\n          else nodeStore.storage.class[item] = [address];\n        });\n      }\n    // Logic for parent component\n    } else {\n      // Setting node id\n      if (node._reactInternalInstance._renderedComponent._hostContainerInfo._node.id) nodeStore.storage.id[node._reactInternalInstance._renderedComponent._hostContainerInfo._node.id] = address;\n      // Setting node classes\n      if (node._reactInternalInstance._renderedComponent._hostContainerInfo._node.className) {\n        classArr = node._reactInternalInstance._renderedComponent._hostContainerInfo._node.className.split(/\\s+/);\n        classArr.forEach(item => {\n          if (nodeStore.storage.class[item]) nodeStore.storage.class[item].push(address)\n          else nodeStore.storage.class[item] = [address];\n        });\n      }\n    } \n  }\n}\n\nconst ReactParentTraverse = (dom) => {\n  // Resets the nodeStore for the new traverse\n  nodeStore.storage = {\n  address: {},\n  id: {}, \n  class: {}, \n  node: {}, \n  tag: {} \n  }; \n\n  // Create a new data object to fill with our parsed DOM. \n  const data = {};\n\n  // Target parent name\n  data.name = dom.constructor.name;\n  // Parent is automatically a smart component, so this is set to true\n  data.component = true;\n  // Setting parent props\n  data.props = dom.props;\n  // Setting parent state \n  data.state = dom.state;\n  // Setting parent address\n  data.address = [dom._reactInternalInstance._hostContainerInfo._node.id, 0];\n  // Setting parent id\n  data.id = dom._reactInternalInstance._renderedComponent._hostContainerInfo._node.id; \n  // Setting parent class\n  data.class = dom._reactInternalInstance._renderedComponent._hostContainerInfo._node.className; \n  // Add necessary data to nodeStore\n  nodeStoreController(dom, data.name, data.address, data.props, data.state, true);\n  // Instantiate the children array for the parent node\n  data.children = [];\n\n  // Setting debugId of parent node to -1. Not sure if React ever uses 0. \n  data.debugId = -1; \n\n\n  // make call to another function where it will traverse through children\n  const children = dom._reactInternalInstance._renderedComponent._renderedChildren; \n  if (children) {\n    Object.values(children).forEach((child, index) => {\n      const address = data.address.slice(0); \n      address.push(index);\n      // Here we start our recursion through the virtual DOM\n      if (child.constructor.name !== 'ReactDOMTextComponent') data.children.push(ReactChildTraverse(child, address));\n    });\n  }\n  // At this point we've finished all of our recursive calls to ReactChildTraverse\n  // So we now check our asserts\n  assert.checkAssert();\n  // and return the data we collected\n  return data;\n};\n\n// Our traversal function for every node but the root node\nconst ReactChildTraverse = (child, address) => {\n  // We declare the object we will be building, starting it with an empty children array\n  const childData = {\n    children: [],\n  };\n  let children;\n  let props;\n  childData.debugId = child._debugID; \n  // set conditional for component vs not\n  if (child.constructor.name === 'ReactCompositeComponentWrapper') {\n    // Parsing logic for smart React Components\n    childData.name = child._currentElement.type.name;\n    childData.component = true;\n\n    // We clone the state to ensure no circular references\n    childData.state = cloneDeep(child._instance.state);\n\n    // If props exist, make a copy of it so we can delete children out of it, otherwise it's null\n    let newProps = child._instance.props !== null ? Object.assign({}, child._instance.props) : null;\n    // Delete children out of props \n    if (newProps.children) delete newProps.children; \n    // Set our props to a cloned version of the props\n    childData.props = cloneDeep(newProps);\n    // Get references to the node's children\n    children = child._renderedComponent._renderedChildren;\n    // Set address, it's either the node's id or the address passed down to the node\n    childData.address = child._renderedComponent._hostNode.id ? [child._renderedComponent._hostNode.id] : address;\n    // Set node's id \n    childData.id = child._renderedComponent._hostNode.id;\n    // Set node's class\n    childData.class = child._renderedComponent._hostNode.className; \n  } else {\n    // Parsing logic for dumb React Components\n    // See above comments if you need to see what is happening here, same logic, different locations\n    childData.name = child._currentElement.type;\n    childData.component = false;\n    childData.state = null;\n    childData.address = child._currentElement.props.id ? [child._currentElement.props.id] : address; \n    var newProps = child._currentElement.props !== null ? Object.assign({}, child._currentElement.props) : null; \n    if (newProps.children) delete newProps.children; \n    childData.props = cloneDeep(newProps);\n    childData.id = childData.props.id; \n    childData.class = childData.props.className; \n    children = child._renderedChildren;\n  }\n\n  // We add the info we've collected for our node to the nodeStore\n  nodeStoreController(child, childData.name, childData.address, childData.props, childData.state);\n\n  // If we have children, set up our recursive calls\n  if (children) {\n      let textNodes = 0; \n      Object.values(children).forEach((child, index) => {\n        // Filter out all React Text Nodes\n        // We may want to add the text data to the parent node on a future revision\n        if (child.constructor.name === 'ReactDOMTextComponent') {\n          textNodes++; \n        } else { \n          // create new Address to pass on to children in recursive call\n          let newAddress = childData.address.slice(0);\n          // Text nodes offset our address algorithm, so we subtract them from our address index to ensure consistency\n          newAddress.push(index - textNodes);\n          // We populate our children array with the results of further recursive calls to the object's children\n          childData.children.push(ReactChildTraverse(child, newAddress));\n        }\n      });\n  }\n  // Delete id and className from props as to not have confusion on the frontend\n  if (childData.props.id) delete childData.props.id; \n  if (childData.props.className) delete childData.props.className;  \n  return childData;\n};\n\n// Creates a clone of an object/array and also clones any objects/arrays that may be nested inside of it\nfunction cloneDeep(value) {\n  if (!(value instanceof Object)) return value; \n  const result = new value.constructor; \n  if (value.constructor === Array) {\n    value.forEach(item => result.push(cloneDeep(item)));\n  } else if (typeof value === 'function') {\n    return 'function'; \n  } else {\n    for (let key in value) {\n    result[key] = cloneDeep(value[key]);\n    }\n  }\n    return result;\n}\n\n\nmodule.exports = {\n  parser\n}"]},"metadata":{},"sourceType":"script"}